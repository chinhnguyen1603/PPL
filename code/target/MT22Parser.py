# Generated from main/mt22/parser/MT22.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3;")
        buf.write("\177\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4")
        buf.write("\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\3\2\3\2\6\2!\n\2\r\2\16\2\"\3\2\3\2\3")
        buf.write("\3\3\3\3\3\5\3*\n\3\3\4\3\4\3\4\3\4\3\4\5\4\61\n\4\3\4")
        buf.write("\3\4\3\5\3\5\3\5\3\5\3\5\5\5:\n\5\3\5\3\5\3\6\5\6?\n\6")
        buf.write("\3\6\5\6B\n\6\3\6\3\6\3\6\3\6\3\7\3\7\3\7\7\7K\n\7\f\7")
        buf.write("\16\7N\13\7\3\b\3\b\3\t\3\t\3\t\7\tU\n\t\f\t\16\tX\13")
        buf.write("\t\3\n\3\n\3\13\3\13\3\13\3\13\3\13\5\13a\n\13\3\f\3\f")
        buf.write("\3\f\3\f\5\fg\n\f\3\r\3\r\3\r\3\r\3\r\7\rn\n\r\f\r\16")
        buf.write("\rq\13\r\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3\16\5\16{\n\16")
        buf.write("\3\17\3\17\3\17\2\2\20\2\4\6\b\n\f\16\20\22\24\26\30\32")
        buf.write("\34\2\3\4\2\t\t\27\27\2\u0085\2 \3\2\2\2\4)\3\2\2\2\6")
        buf.write("+\3\2\2\2\b\64\3\2\2\2\n>\3\2\2\2\fG\3\2\2\2\16O\3\2\2")
        buf.write("\2\20Q\3\2\2\2\22Y\3\2\2\2\24`\3\2\2\2\26f\3\2\2\2\30")
        buf.write("h\3\2\2\2\32z\3\2\2\2\34|\3\2\2\2\36!\5\4\3\2\37!\5\34")
        buf.write("\17\2 \36\3\2\2\2 \37\3\2\2\2!\"\3\2\2\2\" \3\2\2\2\"")
        buf.write("#\3\2\2\2#$\3\2\2\2$%\7\2\2\3%\3\3\2\2\2&*\5\6\4\2\'*")
        buf.write("\5\b\5\2(*\5\n\6\2)&\3\2\2\2)\'\3\2\2\2)(\3\2\2\2*\5\3")
        buf.write("\2\2\2+,\5\20\t\2,-\7\63\2\2-\60\5\32\16\2./\7\66\2\2")
        buf.write("/\61\5\f\7\2\60.\3\2\2\2\60\61\3\2\2\2\61\62\3\2\2\2\62")
        buf.write("\63\7\62\2\2\63\7\3\2\2\2\64\65\5\20\t\2\65\66\7\63\2")
        buf.write("\2\669\5\32\16\2\678\7\66\2\28:\5\f\7\29\67\3\2\2\29:")
        buf.write("\3\2\2\2:;\3\2\2\2;<\7\62\2\2<\t\3\2\2\2=?\7\34\2\2>=")
        buf.write("\3\2\2\2>?\3\2\2\2?A\3\2\2\2@B\7\20\2\2A@\3\2\2\2AB\3")
        buf.write("\2\2\2BC\3\2\2\2CD\7\67\2\2DE\7\63\2\2EF\5\32\16\2F\13")
        buf.write("\3\2\2\2GL\5\16\b\2HI\7\61\2\2IK\5\16\b\2JH\3\2\2\2KN")
        buf.write("\3\2\2\2LJ\3\2\2\2LM\3\2\2\2M\r\3\2\2\2NL\3\2\2\2OP\7")
        buf.write("\5\2\2P\17\3\2\2\2QV\7\67\2\2RS\7\61\2\2SU\7\67\2\2TR")
        buf.write("\3\2\2\2UX\3\2\2\2VT\3\2\2\2VW\3\2\2\2W\21\3\2\2\2XV\3")
        buf.write("\2\2\2YZ\t\2\2\2Z\23\3\2\2\2[a\7\5\2\2\\a\7\6\2\2]a\7")
        buf.write("\7\2\2^a\5\22\n\2_a\5\30\r\2`[\3\2\2\2`\\\3\2\2\2`]\3")
        buf.write("\2\2\2`^\3\2\2\2`_\3\2\2\2a\25\3\2\2\2bg\5\22\n\2cg\7")
        buf.write("\n\2\2dg\7\16\2\2eg\7\23\2\2fb\3\2\2\2fc\3\2\2\2fd\3\2")
        buf.write("\2\2fe\3\2\2\2g\27\3\2\2\2hi\7\f\2\2ij\7\64\2\2jo\7\5")
        buf.write("\2\2kl\7\61\2\2ln\7\5\2\2mk\3\2\2\2nq\3\2\2\2om\3\2\2")
        buf.write("\2op\3\2\2\2pr\3\2\2\2qo\3\2\2\2rs\7\65\2\2st\7\30\2\2")
        buf.write("tu\5\26\f\2u\31\3\2\2\2v{\5\26\f\2w{\5\30\r\2x{\7\13\2")
        buf.write("\2y{\7\b\2\2zv\3\2\2\2zw\3\2\2\2zx\3\2\2\2zy\3\2\2\2{")
        buf.write("\33\3\2\2\2|}\7\26\2\2}\35\3\2\2\2\17 \")\609>ALV`foz")
        return buf.getvalue()


class MT22Parser ( Parser ):

    grammarFileName = "MT22.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'auto'", "'false'", "'integer'", 
                     "'void'", "'array'", "'break'", "'float'", "'return'", 
                     "'out'", "'boolean'", "'for'", "'string'", "'continue'", 
                     "'do'", "'function'", "'true'", "'of'", "'else'", "'if'", 
                     "'while'", "'inherit'", "'+'", "'-'", "'*'", "'/'", 
                     "'%'", "'!'", "'&&'", "'||'", "'=='", "'!='", "'<'", 
                     "'<='", "'>'", "'>='", "'::'", "'('", "')'", "'['", 
                     "']'", "'.'", "','", "';'", "':'", "'{'", "'}'", "'='" ]

    symbolicNames = [ "<INVALID>", "COMMENT_C", "COMMENT_CPLUS", "INT_LIT", 
                      "FLOAT_LIT", "STRING_LIT", "AUTO", "FALSE", "INTERGER", 
                      "VOID", "ARRAY", "BREAK", "FLOAT", "RETURN", "OUT", 
                      "BOOLEAN", "FOR", "STRING", "CONTINUE", "DO", "FUNCTION", 
                      "TRUE", "OF", "ELSE", "IF", "WHILE", "INHERIT", "ADDOP", 
                      "SUBOP", "MULOP", "DIV", "MOD", "NOT", "AND", "OR", 
                      "EQUAL", "NOT_EQUAL", "LESS", "LESS_OR_EQUAL", "GREATER", 
                      "GREATER_OR_EQUAL", "DOUBLE_COLON", "LB", "RB", "LSB", 
                      "RSB", "DOT", "COMMA", "SEMICOLON", "COLON", "LP", 
                      "RP", "ASSIGN", "ID", "WS", "ERROR_CHAR", "UNCLOSE_STRING", 
                      "ILLEGAL_ESCAPE" ]

    RULE_program = 0
    RULE_var_decl = 1
    RULE_global_var_decl = 2
    RULE_local_var_decl = 3
    RULE_parameter_of_func = 4
    RULE_list_expr = 5
    RULE_expr = 6
    RULE_id_list = 7
    RULE_boolean_literal = 8
    RULE_literal = 9
    RULE_atomic_typ = 10
    RULE_array_literal = 11
    RULE_typ = 12
    RULE_func_decl = 13

    ruleNames =  [ "program", "var_decl", "global_var_decl", "local_var_decl", 
                   "parameter_of_func", "list_expr", "expr", "id_list", 
                   "boolean_literal", "literal", "atomic_typ", "array_literal", 
                   "typ", "func_decl" ]

    EOF = Token.EOF
    COMMENT_C=1
    COMMENT_CPLUS=2
    INT_LIT=3
    FLOAT_LIT=4
    STRING_LIT=5
    AUTO=6
    FALSE=7
    INTERGER=8
    VOID=9
    ARRAY=10
    BREAK=11
    FLOAT=12
    RETURN=13
    OUT=14
    BOOLEAN=15
    FOR=16
    STRING=17
    CONTINUE=18
    DO=19
    FUNCTION=20
    TRUE=21
    OF=22
    ELSE=23
    IF=24
    WHILE=25
    INHERIT=26
    ADDOP=27
    SUBOP=28
    MULOP=29
    DIV=30
    MOD=31
    NOT=32
    AND=33
    OR=34
    EQUAL=35
    NOT_EQUAL=36
    LESS=37
    LESS_OR_EQUAL=38
    GREATER=39
    GREATER_OR_EQUAL=40
    DOUBLE_COLON=41
    LB=42
    RB=43
    LSB=44
    RSB=45
    DOT=46
    COMMA=47
    SEMICOLON=48
    COLON=49
    LP=50
    RP=51
    ASSIGN=52
    ID=53
    WS=54
    ERROR_CHAR=55
    UNCLOSE_STRING=56
    ILLEGAL_ESCAPE=57

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(MT22Parser.EOF, 0)

        def var_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MT22Parser.Var_declContext)
            else:
                return self.getTypedRuleContext(MT22Parser.Var_declContext,i)


        def func_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MT22Parser.Func_declContext)
            else:
                return self.getTypedRuleContext(MT22Parser.Func_declContext,i)


        def getRuleIndex(self):
            return MT22Parser.RULE_program

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = MT22Parser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 30 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 30
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [MT22Parser.OUT, MT22Parser.INHERIT, MT22Parser.ID]:
                    self.state = 28
                    self.var_decl()
                    pass
                elif token in [MT22Parser.FUNCTION]:
                    self.state = 29
                    self.func_decl()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 32 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MT22Parser.OUT) | (1 << MT22Parser.FUNCTION) | (1 << MT22Parser.INHERIT) | (1 << MT22Parser.ID))) != 0)):
                    break

            self.state = 34
            self.match(MT22Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Var_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def global_var_decl(self):
            return self.getTypedRuleContext(MT22Parser.Global_var_declContext,0)


        def local_var_decl(self):
            return self.getTypedRuleContext(MT22Parser.Local_var_declContext,0)


        def parameter_of_func(self):
            return self.getTypedRuleContext(MT22Parser.Parameter_of_funcContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_var_decl

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar_decl" ):
                return visitor.visitVar_decl(self)
            else:
                return visitor.visitChildren(self)




    def var_decl(self):

        localctx = MT22Parser.Var_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_var_decl)
        try:
            self.state = 39
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 36
                self.global_var_decl()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 37
                self.local_var_decl()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 38
                self.parameter_of_func()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Global_var_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def id_list(self):
            return self.getTypedRuleContext(MT22Parser.Id_listContext,0)


        def COLON(self):
            return self.getToken(MT22Parser.COLON, 0)

        def typ(self):
            return self.getTypedRuleContext(MT22Parser.TypContext,0)


        def SEMICOLON(self):
            return self.getToken(MT22Parser.SEMICOLON, 0)

        def ASSIGN(self):
            return self.getToken(MT22Parser.ASSIGN, 0)

        def list_expr(self):
            return self.getTypedRuleContext(MT22Parser.List_exprContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_global_var_decl

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGlobal_var_decl" ):
                return visitor.visitGlobal_var_decl(self)
            else:
                return visitor.visitChildren(self)




    def global_var_decl(self):

        localctx = MT22Parser.Global_var_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_global_var_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 41
            self.id_list()
            self.state = 42
            self.match(MT22Parser.COLON)
            self.state = 43
            self.typ()
            self.state = 46
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MT22Parser.ASSIGN:
                self.state = 44
                self.match(MT22Parser.ASSIGN)
                self.state = 45
                self.list_expr()


            self.state = 48
            self.match(MT22Parser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Local_var_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def id_list(self):
            return self.getTypedRuleContext(MT22Parser.Id_listContext,0)


        def COLON(self):
            return self.getToken(MT22Parser.COLON, 0)

        def typ(self):
            return self.getTypedRuleContext(MT22Parser.TypContext,0)


        def SEMICOLON(self):
            return self.getToken(MT22Parser.SEMICOLON, 0)

        def ASSIGN(self):
            return self.getToken(MT22Parser.ASSIGN, 0)

        def list_expr(self):
            return self.getTypedRuleContext(MT22Parser.List_exprContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_local_var_decl

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocal_var_decl" ):
                return visitor.visitLocal_var_decl(self)
            else:
                return visitor.visitChildren(self)




    def local_var_decl(self):

        localctx = MT22Parser.Local_var_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_local_var_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 50
            self.id_list()
            self.state = 51
            self.match(MT22Parser.COLON)
            self.state = 52
            self.typ()
            self.state = 55
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MT22Parser.ASSIGN:
                self.state = 53
                self.match(MT22Parser.ASSIGN)
                self.state = 54
                self.list_expr()


            self.state = 57
            self.match(MT22Parser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Parameter_of_funcContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MT22Parser.ID, 0)

        def COLON(self):
            return self.getToken(MT22Parser.COLON, 0)

        def typ(self):
            return self.getTypedRuleContext(MT22Parser.TypContext,0)


        def INHERIT(self):
            return self.getToken(MT22Parser.INHERIT, 0)

        def OUT(self):
            return self.getToken(MT22Parser.OUT, 0)

        def getRuleIndex(self):
            return MT22Parser.RULE_parameter_of_func

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter_of_func" ):
                return visitor.visitParameter_of_func(self)
            else:
                return visitor.visitChildren(self)




    def parameter_of_func(self):

        localctx = MT22Parser.Parameter_of_funcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_parameter_of_func)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 60
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MT22Parser.INHERIT:
                self.state = 59
                self.match(MT22Parser.INHERIT)


            self.state = 63
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MT22Parser.OUT:
                self.state = 62
                self.match(MT22Parser.OUT)


            self.state = 65
            self.match(MT22Parser.ID)
            self.state = 66
            self.match(MT22Parser.COLON)
            self.state = 67
            self.typ()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class List_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MT22Parser.ExprContext)
            else:
                return self.getTypedRuleContext(MT22Parser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(MT22Parser.COMMA)
            else:
                return self.getToken(MT22Parser.COMMA, i)

        def getRuleIndex(self):
            return MT22Parser.RULE_list_expr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitList_expr" ):
                return visitor.visitList_expr(self)
            else:
                return visitor.visitChildren(self)




    def list_expr(self):

        localctx = MT22Parser.List_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_list_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self.expr()
            self.state = 74
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==MT22Parser.COMMA:
                self.state = 70
                self.match(MT22Parser.COMMA)
                self.state = 71
                self.expr()
                self.state = 76
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_LIT(self):
            return self.getToken(MT22Parser.INT_LIT, 0)

        def getRuleIndex(self):
            return MT22Parser.RULE_expr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr" ):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)




    def expr(self):

        localctx = MT22Parser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            self.match(MT22Parser.INT_LIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Id_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(MT22Parser.ID)
            else:
                return self.getToken(MT22Parser.ID, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(MT22Parser.COMMA)
            else:
                return self.getToken(MT22Parser.COMMA, i)

        def getRuleIndex(self):
            return MT22Parser.RULE_id_list

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitId_list" ):
                return visitor.visitId_list(self)
            else:
                return visitor.visitChildren(self)




    def id_list(self):

        localctx = MT22Parser.Id_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_id_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 79
            self.match(MT22Parser.ID)
            self.state = 84
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==MT22Parser.COMMA:
                self.state = 80
                self.match(MT22Parser.COMMA)
                self.state = 81
                self.match(MT22Parser.ID)
                self.state = 86
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Boolean_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(MT22Parser.TRUE, 0)

        def FALSE(self):
            return self.getToken(MT22Parser.FALSE, 0)

        def getRuleIndex(self):
            return MT22Parser.RULE_boolean_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolean_literal" ):
                return visitor.visitBoolean_literal(self)
            else:
                return visitor.visitChildren(self)




    def boolean_literal(self):

        localctx = MT22Parser.Boolean_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_boolean_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 87
            _la = self._input.LA(1)
            if not(_la==MT22Parser.FALSE or _la==MT22Parser.TRUE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_LIT(self):
            return self.getToken(MT22Parser.INT_LIT, 0)

        def FLOAT_LIT(self):
            return self.getToken(MT22Parser.FLOAT_LIT, 0)

        def STRING_LIT(self):
            return self.getToken(MT22Parser.STRING_LIT, 0)

        def boolean_literal(self):
            return self.getTypedRuleContext(MT22Parser.Boolean_literalContext,0)


        def array_literal(self):
            return self.getTypedRuleContext(MT22Parser.Array_literalContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = MT22Parser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_literal)
        try:
            self.state = 94
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MT22Parser.INT_LIT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 89
                self.match(MT22Parser.INT_LIT)
                pass
            elif token in [MT22Parser.FLOAT_LIT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 90
                self.match(MT22Parser.FLOAT_LIT)
                pass
            elif token in [MT22Parser.STRING_LIT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 91
                self.match(MT22Parser.STRING_LIT)
                pass
            elif token in [MT22Parser.FALSE, MT22Parser.TRUE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 92
                self.boolean_literal()
                pass
            elif token in [MT22Parser.ARRAY]:
                self.enterOuterAlt(localctx, 5)
                self.state = 93
                self.array_literal()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Atomic_typContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolean_literal(self):
            return self.getTypedRuleContext(MT22Parser.Boolean_literalContext,0)


        def INTERGER(self):
            return self.getToken(MT22Parser.INTERGER, 0)

        def FLOAT(self):
            return self.getToken(MT22Parser.FLOAT, 0)

        def STRING(self):
            return self.getToken(MT22Parser.STRING, 0)

        def getRuleIndex(self):
            return MT22Parser.RULE_atomic_typ

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomic_typ" ):
                return visitor.visitAtomic_typ(self)
            else:
                return visitor.visitChildren(self)




    def atomic_typ(self):

        localctx = MT22Parser.Atomic_typContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_atomic_typ)
        try:
            self.state = 100
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MT22Parser.FALSE, MT22Parser.TRUE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 96
                self.boolean_literal()
                pass
            elif token in [MT22Parser.INTERGER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 97
                self.match(MT22Parser.INTERGER)
                pass
            elif token in [MT22Parser.FLOAT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 98
                self.match(MT22Parser.FLOAT)
                pass
            elif token in [MT22Parser.STRING]:
                self.enterOuterAlt(localctx, 4)
                self.state = 99
                self.match(MT22Parser.STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Array_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(MT22Parser.ARRAY, 0)

        def LP(self):
            return self.getToken(MT22Parser.LP, 0)

        def INT_LIT(self, i:int=None):
            if i is None:
                return self.getTokens(MT22Parser.INT_LIT)
            else:
                return self.getToken(MT22Parser.INT_LIT, i)

        def RP(self):
            return self.getToken(MT22Parser.RP, 0)

        def OF(self):
            return self.getToken(MT22Parser.OF, 0)

        def atomic_typ(self):
            return self.getTypedRuleContext(MT22Parser.Atomic_typContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(MT22Parser.COMMA)
            else:
                return self.getToken(MT22Parser.COMMA, i)

        def getRuleIndex(self):
            return MT22Parser.RULE_array_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArray_literal" ):
                return visitor.visitArray_literal(self)
            else:
                return visitor.visitChildren(self)




    def array_literal(self):

        localctx = MT22Parser.Array_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_array_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self.match(MT22Parser.ARRAY)
            self.state = 103
            self.match(MT22Parser.LP)
            self.state = 104
            self.match(MT22Parser.INT_LIT)
            self.state = 109
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==MT22Parser.COMMA:
                self.state = 105
                self.match(MT22Parser.COMMA)
                self.state = 106
                self.match(MT22Parser.INT_LIT)
                self.state = 111
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 112
            self.match(MT22Parser.RP)
            self.state = 113
            self.match(MT22Parser.OF)
            self.state = 114
            self.atomic_typ()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_typ(self):
            return self.getTypedRuleContext(MT22Parser.Atomic_typContext,0)


        def array_literal(self):
            return self.getTypedRuleContext(MT22Parser.Array_literalContext,0)


        def VOID(self):
            return self.getToken(MT22Parser.VOID, 0)

        def AUTO(self):
            return self.getToken(MT22Parser.AUTO, 0)

        def getRuleIndex(self):
            return MT22Parser.RULE_typ

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTyp" ):
                return visitor.visitTyp(self)
            else:
                return visitor.visitChildren(self)




    def typ(self):

        localctx = MT22Parser.TypContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_typ)
        try:
            self.state = 120
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MT22Parser.FALSE, MT22Parser.INTERGER, MT22Parser.FLOAT, MT22Parser.STRING, MT22Parser.TRUE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 116
                self.atomic_typ()
                pass
            elif token in [MT22Parser.ARRAY]:
                self.enterOuterAlt(localctx, 2)
                self.state = 117
                self.array_literal()
                pass
            elif token in [MT22Parser.VOID]:
                self.enterOuterAlt(localctx, 3)
                self.state = 118
                self.match(MT22Parser.VOID)
                pass
            elif token in [MT22Parser.AUTO]:
                self.enterOuterAlt(localctx, 4)
                self.state = 119
                self.match(MT22Parser.AUTO)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Func_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCTION(self):
            return self.getToken(MT22Parser.FUNCTION, 0)

        def getRuleIndex(self):
            return MT22Parser.RULE_func_decl

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunc_decl" ):
                return visitor.visitFunc_decl(self)
            else:
                return visitor.visitChildren(self)




    def func_decl(self):

        localctx = MT22Parser.Func_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_func_decl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self.match(MT22Parser.FUNCTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





